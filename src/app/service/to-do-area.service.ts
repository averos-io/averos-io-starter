  
import { HttpClient, HttpParams } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { AverosSearchOperator, SearchInputCriteria, ApplicationSharedService } from '@wiforge/averos';
import {Observable, of } from 'rxjs';
import { mergeMap } from 'rxjs/operators';

import { ToDoArea } from '../model/to-do-area';

@Injectable({
  providedIn: 'root'
})
export class ToDoAreaService {

// This is an autogenerated service url
// TODO: update with your custom service url data

 public toDoAreaAPI = 'http://localhost:3333/api/todoareas';
 public toDoTaskAPI = 'http://localhost:3333/api/todotasks';

  

  constructor(private httpClient: HttpClient,
              private applicationSharedService: ApplicationSharedService) { }

  updateEntity(id: any, entityTopdate: any | Partial<any>): Observable<any> {
    const data = { ...entityTopdate }
    data.updatedBy =  this.applicationSharedService.getLoggedUser();
    data.updatedAt = new Date();
    return this.httpClient.patch<any>(`${this.toDoAreaAPI}/${id}`, data);
  }
  

  createEntity(value: any): Observable<any> {
    value.createdBy =  this.applicationSharedService.getLoggedUser();
    value.createdAt = new Date();
    return this.httpClient.post<any>(this.toDoAreaAPI, value);
  }

  deleteEntity(id: any): Observable<any> {
    return this.httpClient.delete<any>(`${this.toDoAreaAPI}/${id}`);
  }

  getAllEntities(): Observable<ToDoArea[]> {
    return this.httpClient.get<any[]>(this.toDoAreaAPI);
  }

  getEntityById(id: string): Observable<any> {

    return this.httpClient.get<any>(`${this.toDoAreaAPI}/${id}`);
  }

  getEntitiesByIds(ids: string[]): Observable<any> {
    const criteriaz = 
                      {id:
                        {
                          entityAccessor: 'id',
                          entityValue: ids,
                          operator: AverosSearchOperator.OPER_IN_ELEMENTS
                        }
                      };
      if (ids && ids.length > 0){
          return this.getEntitiesByCriteria(new SearchInputCriteria(criteriaz));
        }
      return of();
  }

  getEntitiesByCriteria(criteria: SearchInputCriteria): Observable<any>{

    let query: string;

    if (criteria === undefined || criteria === null){
      return of();
    }   

    query = criteria.toHttpQuery('REGULAR');
    const opts =  {
                    params: new HttpParams({fromString: query})
                   };
    return this.httpClient.get<any[]>(this.toDoAreaAPI, opts);
  }

  /**
   * 
   * @param id the parent entity id
   * @param relationName : The collection relation Name
   * @param cids : the ids of the collection to be removed from the parent entity
   * @returns 
   * 
   * N.B: cids: {id: string}[]) : cids structure depends on the identifier name of the entity:
   * ex: id entity'identifier == 
   *                              + "_id" ==> cids: {_id: string}[]
   *                              + "_id" ==> cids: {_id: string}[]
   *                              + "identifier" ==> cids: {identifier: string}[]
   *                              + "some_id" ==> cids: {some_id: string}[]
   *                              + ...ect...
   */
   deleteRelationCollection(parentId: any, relationName: string, cids: {id: string}[]): Observable<any> {

    let operations: Observable<any> | null = null;
    const data: any = {};
  
    data['updatedBy'] =  this.applicationSharedService.getLoggedUser();
    data['updatedAt'] = new Date();

    //'inline-loading' places a loading progress indicator inside the most inner html component.
    // Set it to 'false' or ommit it in order to delegate to the global application loader located
    // in the root html element.
    const options = {
      headers: {
        'inline-loading': 'true'
      }
    }

     /**
       * TODO: update the target elements in the collection by removing the parent id
       * then 
       * update the parent's updateBy field
       */

    
       if (relationName === 'toDoTasks'){
        operations = cids.reduce((previousValue: Observable<any> | null, currentValue: {id: string}) => {
          previousValue = previousValue != null 
            ? previousValue.pipe(mergeMap(el => this.httpClient.patch<any>(`${this.toDoTaskAPI}/${currentValue.id}`, {"toDoAreaId": ""}, options))) 
            : this.httpClient.patch<any>(`${this.toDoTaskAPI}/${currentValue.id}`, {"toDoAreaId": ""}, options);
          return previousValue;
        }, operations);
      }
        
if (operations !== null){
      return  (operations as Observable<any>).pipe(mergeMap(e => this.httpClient.patch<any>(`${this.toDoAreaAPI}/${parentId}` , data)));
    } else {
      return this.httpClient.patch<any>(`${this.toDoAreaAPI}/${parentId}` , data);
    }
  }

    /**
   * 
   * @param parentId the parent entity id 
   * @param relationName : The collection relation Name
   * @param cids : the ids of the collection to be added from the parent entity
   * @returns 
   */
     addRelationCollection(parentId: any, relationName: string, cids: {id: string}[]): Observable<any> {

      let operations: Observable<any> | null = null;
      const data: any = {};
    
      data['updatedBy'] =  this.applicationSharedService.getLoggedUser();
      data['updatedAt'] = new Date();

      //'inline-loading' places a loading progress indicator inside the most inner html component.
      // Set it to 'false' or ommit it in order to delegate to the global application loader located
      // in the root html element.
      const options = {
        headers: {
          'inline-loading': 'true'
        }
      }

      /**
       * TODO: update the target elements in the collection by setting the parent id
       * then 
       * update the parent's updateBy field
       */

      
       if (relationName === 'toDoTasks'){
        operations = cids.reduce((previousValue: Observable<any> | null, currentValue: {id: string}) => {
          previousValue = previousValue != null 
            ? previousValue.pipe(mergeMap(el => this.httpClient.patch<any>(`${this.toDoTaskAPI}/${currentValue.id}`, {"toDoAreaId": parentId}, options))) 
            : this.httpClient.patch<any>(`${this.toDoTaskAPI}/${currentValue.id}`, {"toDoAreaId": parentId}, options);
          return previousValue;
        }, operations);
      }
        
if (operations !== null){
          return  (operations as Observable<any>).pipe(mergeMap(e => this.httpClient.patch<any>(`${this.toDoAreaAPI}/${parentId}` , data)));
       } else {
          return this.httpClient.patch<any>(`${this.toDoAreaAPI}/${parentId}` , data);
       }
    }
  
}